# Lua Module Embedding

This build embeds `resty.upstream.healthcheck` into the nginx binary as LuaJIT bytecode. No runtime `.lua` files are shipped in the final image.

## Why Embed

The healthcheck module is compiled to LuaJIT bytecode and statically linked during the nginx build. This removes runtime Lua file dependencies for the healthcheck module.

## How It Works

The build process follows these steps:

1. Rename the module file - `lib/resty/upstream/healthcheck.lua` is copied as `resty_upstream_healthcheck.lua`.

2. Compile to bytecode - The LuaJIT compiler generates an object file:

   ```bash
   luajit -bg resty_upstream_healthcheck.lua resty_upstream_healthcheck.o
   ```

   The `-b` flag produces bytecode and `-g` includes debug information.

3. Link during nginx build - The generated object file is linked into nginx via `--with-ld-opt`.

   ```bash
   --with-ld-opt="/build/resty_upstream_healthcheck.o -static -static-pie ..."
   ```

## Module Name Mapping

Lua modules use dot-separated names in `require()` calls but map to underscore-separated file names for LuaJIT compilation:

| Module Name | File Name |
| --- | --- |
| `resty.upstream.healthcheck` | `resty_upstream_healthcheck.lua` |

## LuaJIT Version Compatibility

The bytecode generated by LuaJIT is version-specific. The LuaJIT version used during compilation MUST match the LuaJIT version at runtime. This build uses Alpine package registry `luajit` for both compilation and runtime linking to keep that version aligned.

## Scope

This repository embeds only `resty.upstream.healthcheck` into the binary. Additional lua-resty libraries are not included.

## Comprehensive Runtime Example

Use one `http {}` example that includes multiple upstream checks, automatic peer down/up handling, and metrics exposure.

```nginx
http {
    upstream foo {
        server 10.0.1.11:8080;
        server 10.0.1.12:8080;
    }

    upstream bar {
        server 10.0.2.11:8080;
        server 10.0.2.12:8080;
    }

    lua_shared_dict healthcheck 20m;
    lua_socket_log_errors off;

    init_worker_by_lua_block {
        local hc = require "resty.upstream.healthcheck"
        local ok, err = hc.spawn_checker({
            shm = "healthcheck",
            upstream = "foo",
            type = "http",
            http_req = "GET /readyz HTTP/1.0\r\nHost: foo.internal\r\n\r\n",
            interval = 2000,
            timeout = 1000,
            fall = 3,
            rise = 2,
            valid_statuses = {200, 204},
            concurrency = 10,
        })

        if not ok then
            ngx.log(ngx.ERR, "failed to spawn health checker for foo: ", err)
        end

        ok, err = hc.spawn_checker({
            shm = "healthcheck",
            upstream = "bar",
            type = "https",
            http_req = "GET /healthz HTTP/1.0\r\nHost: bar.internal\r\n\r\n",
            interval = 5000,
            timeout = 2000,
            fall = 5,
            rise = 3,
            valid_statuses = {200},
            concurrency = 5,
            ssl_verify = true,
            host = "bar.internal",
        })

        if not ok then
            ngx.log(ngx.ERR, "failed to spawn health checker for bar: ", err)
        end
    }

    server {
        listen 80;

        location /api/ {
            proxy_pass http://foo;
        }

        location / {
            proxy_pass http://bar;
        }
    }

    server {
        listen 127.0.0.1:18080;

        location = /status {
            access_log off;
            default_type text/plain;
            content_by_lua_block {
                local hc = require "resty.upstream.healthcheck"
                ngx.print(hc.status_page())
            }
        }

        location = /metrics {
            access_log off;
            default_type text/plain;
            content_by_lua_block {
                local hc = require "resty.upstream.healthcheck"
                local out, err = hc.prometheus_status_page()
                if not out then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say(err)
                    return
                end
                ngx.print(out)
            }
        }
    }
}
```

Each checker updates peer state via `ngx.upstream.set_peer_down`. Failed peers are marked down after `fall` consecutive failures and recovered after `rise` consecutive successes. For external scraping, keep `/metrics` behind network policy, IP allowlists, or an internal-only listener.

## Nginx VTS Example

If you also use `nginx-vts-module`, expose traffic statistics in Prometheus format.

```nginx
http {
    vhost_traffic_status_zone;

    server {
        listen 127.0.0.1:18081;

        location = /metrics/vts {
            access_log off;
            vhost_traffic_status_display;
            vhost_traffic_status_display_format prometheus;
        }
    }
}
```

This endpoint is independent from `resty.upstream.healthcheck` status and is useful for request/traffic volume monitoring.

## Reference

See [lua-nginx-module README](https://github.com/openresty/lua-nginx-module) (section "Statically Linking Pure Lua Modules") for the canonical documentation on this embedding technique.
