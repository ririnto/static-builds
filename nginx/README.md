# Lua Module Embedding

This build embeds `resty.upstream.healthcheck` into the nginx binary as LuaJIT bytecode. No runtime `.lua` files are shipped in the final image.

## Why Embed

The healthcheck module is compiled to LuaJIT bytecode and statically linked during the nginx build. This removes runtime Lua file dependencies for the healthcheck module.

## How It Works

The build process follows these steps:

1. Rename the module file - `lib/resty/upstream/healthcheck.lua` is copied as `resty_upstream_healthcheck.lua`.

2. Compile to bytecode - The LuaJIT compiler generates an object file:

   ```bash
   luajit -bg resty_upstream_healthcheck.lua resty_upstream_healthcheck.o
   ```

   The `-b` flag produces bytecode and `-g` includes debug information.

3. Link during nginx build - The generated object file is linked into nginx via `--with-ld-opt`.

   ```bash
   --with-ld-opt="/build/resty_upstream_healthcheck.o -static -static-pie ..."
   ```

## Module Name Mapping

Lua modules use dot-separated names in `require()` calls but map to underscore-separated file names for LuaJIT compilation:

| Module Name | File Name |
| --- | --- |
| `resty.upstream.healthcheck` | `resty_upstream_healthcheck.lua` |

## LuaJIT Version Compatibility

The bytecode generated by LuaJIT is version-specific. The LuaJIT version used during compilation MUST match the LuaJIT version at runtime. This build uses Alpine package registry `luajit` for both compilation and runtime linking to keep that version aligned.

## Scope

This repository embeds only `resty.upstream.healthcheck` into the binary. Additional lua-resty libraries are not included.

## Upstream Auto-Eviction Setup

Healthcheck failure can be reflected in normal upstream routing by spawning a checker for the target `upstream` group.

Use the pattern below in your runtime nginx config:

```nginx
lua_shared_dict healthcheck 10m;

upstream backend {
    server 10.0.0.11:8080;
    server 10.0.0.12:8080;
}

init_worker_by_lua_block {
    local hc = require "resty.upstream.healthcheck"
    local ok, err = hc.spawn_checker({
        shm = "healthcheck",
        upstream = "backend",
        type = "http",
        http_req = "GET /healthz HTTP/1.0\r\nHost: backend\r\n\r\n",
        interval = 2000,
        timeout = 1000,
        fall = 3,
        rise = 2,
        valid_statuses = {200, 204},
        concurrency = 10,
    })
    if not ok then
        ngx.log(ngx.ERR, "failed to spawn health checker: ", err)
    end
}

server {
    listen 80;

    location / {
        proxy_pass http://backend;
    }
}
```

`spawn_checker` updates peer state through `ngx.upstream.set_peer_down`. If a peer keeps failing (`fall` threshold), it is marked down and skipped until it passes enough checks (`rise` threshold).

## Reference

See [lua-nginx-module README](https://github.com/openresty/lua-nginx-module) (section "Statically Linking Pure Lua Modules") for the canonical documentation on this embedding technique.
