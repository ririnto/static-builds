# Lua Module Embedding

This build embeds `resty.upstream.healthcheck` into the nginx binary as LuaJIT bytecode. No runtime `.lua` files are shipped in the final image.

## Why Embed

The healthcheck module is compiled to LuaJIT bytecode and statically linked during the nginx build. This removes runtime Lua file dependencies for the healthcheck module.

## How It Works

The build process follows these steps:

1. **Rename the module file** - `lib/resty/upstream/healthcheck.lua` is copied as `resty_upstream_healthcheck.lua`.

2. **Compile to bytecode** - The LuaJIT compiler generates an object file:

   ```bash
   luajit -bg resty_upstream_healthcheck.lua resty_upstream_healthcheck.o
   ```

   The `-b` flag produces bytecode and `-g` includes debug information.

3. **Link during nginx build** - The generated object file is linked into nginx via `--with-ld-opt`.

   ```bash
   --with-ld-opt="/build/resty_upstream_healthcheck.o -static -static-pie ..."
   ```

## Module Name Mapping

Lua modules use dot-separated names in `require()` calls but map to underscore-separated file names for LuaJIT compilation:

| Module Name | File Name |
| --- | --- |
| `resty.upstream.healthcheck` | `resty_upstream_healthcheck.lua` |

## LuaJIT Version Compatibility

The bytecode generated by LuaJIT is version-specific. The LuaJIT version used during compilation MUST match the LuaJIT version at runtime. This build locks both versions to the same Alpine package to ensure compatibility.

## Scope

This repository embeds only `resty.upstream.healthcheck` into the binary. Additional lua-resty libraries are not included.

The verify configuration also checks the underscore fallback module key (`resty_upstream_healthcheck`) and maps it to `resty.upstream.healthcheck` when needed.

## Reference

See `third-party/lua-nginx-module/README.markdown` (section "Statically Linking Pure Lua Modules") for the canonical documentation on this embedding technique.
